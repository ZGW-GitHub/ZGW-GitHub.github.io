> 前面提过实现并发编程要解决两个关键问题，其中 Java 是采用**共享内存(隐式通信)**来解决线程间通信的，下面我们就了解下 Java 的内存模型（ 也即：JMM ）。

# Java 内存模型的抽象结构

| 内存分类 | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| 主内存   | 线程之间的共享变量存储在主内存中。                           |
| 本地内存 | - 每个线程都有一个私有的本地内存。<br />- 本地内存是 JVM 的一个抽象概念，并不真实存在。<br />  它涵盖了缓存、写缓冲区、寄存器以及其它的硬件和编译器优化。 |

![image-20210912195713332](https://raw.githubusercontent.com/ZGW-GitHub/NoteImages/main/transfer/blog-img-master/2021/09/12/19/image-20210912195713332_1631447833478.png)

# 可见性、原子性、有序性

| 知识点 | 说明                                         |
| ------ | -------------------------------------------- |
| 可见性 | 通俗讲就是线程 A 对内存的修改对线程 B 可见。 |
| 原子性 | 这些操作要么全部完成要么全部失败。           |
| 有序性 | 具备有序性：不会发生指令重排序。             |

## 1、可见性



## 2、原子性

### 32 位虚拟机的 long 、double 写非原子

**32 位虚拟机**里的 long 、double 类型的变量的简单赋值、写操作，不是原子的，因为：long 、double 是 64 位的，若多个线程执行 long i = 30 时，会导致有的线程在修改 i 的高 32 位，有的线程在修改 i 的低 32 位。

**解决：**对 long 、double 变量使用 volatile 修饰，就可以保证了其的原子性。

**注意：**volatile 也就只保证这一种情况的原子性了，其它情况并不能保证原子性。

## 3、有序性

# 关键字：Volatile ( 可见性、有序性 )

> 只能保证**内存可见性**以及**防止指令重排序**，**不能保证原子性**。
>
> 防止指令重排序是通过`“内存屏障”`来实现的。

## 1、相关的 CPU 术语

|    术语    | 说明                                                         |
| :--------: | ------------------------------------------------------------ |
|  内存屏障  | 是一组处理器指令，用于实现对内存操作的顺序限制。             |
|   缓存行   | CPU 高速缓存（ L1 、L2 、L3 ）中可以分配的最小存储单位。<br />处理器填写缓存行时会加载整个缓存行。 |
|  原子操作  | 不可中断的一个或一系列操作。                                 |
| 缓存行填充 | 当处理器识别到从内存中读取的数据是可缓存的，<br />处理器会将其缓存到适当的高速缓存中（ L1 / L2 / L3 或 全部都存 ）。 |
|  缓存命中  | 当处理器要读取的数据在高速缓存中存在，<br />处理器会从缓存中读取数据，而不是从内存中读取。 |
|   写命中   | 当处理器写数据时，若数据在高速缓存中存在并且是有效的，<br />则处理器会将数据写到缓存而不是写到内存。 |
|   写缺失   | 当处理器写数据时，数据在高速缓存中不存在。                   |

## 2、volatile 保证有序性的实现原理

### a、导致无序性的病因：重排序

> 在执行程序时，为了提高性能，编译器和处理器常常会对指令序列做重排序。
>
> ![重排序](https://raw.githubusercontent.com/ZGW-GitHub/NoteImages/main/transfer/blog-img-master/2020/11/%E9%87%8D%E6%8E%92%E5%BA%8F_1606032037175.png)

#### 3 种重排序

1. `编译器优化的重排序`

	编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。

2. 处理器优化的重排序：`指令级的重排序`

	现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖，处理器可以改变语句对应机器指令的执行顺序。

3. 处理器优化的重排序：`内存系统的重排序`

	由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

### b、有序性如何实现：对重排序加以限制

上面说了为了提高性能，编译器和处理器必须对指令序列做重排序，但为了保证程序执行的正确性，JMM 对重排序加了一些限制，即：不能随意地进行重排序。

- **对于编译器重排序：**会禁止特定类型的编译器重排序。

- **对于处理器重排序：**会要求 Java 编译器在生成指令序列时，在不能重排序的指令前/后插入特定类型的`内存屏障`指令，通过内存屏障指令来禁止特定类型的处理器重排序。

### c、volatile 如何实现的有序性：内存屏障

上面说了：对于处理器重排序，会要求 Java 编译器在生成指令序列时，在不能重排序的指令前/后插入特定类型的`内存屏障`指令，来禁止特定类型的处理器重排序。

而 JMM 为了实现 volatile 的**有序性**和**可见性**，定义了 4 种内存屏障：

![内存屏障类型表](https://raw.githubusercontent.com/ZGW-GitHub/NoteImages/main/transfer/blog-img-master/2020/11/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E7%B1%BB%E5%9E%8B%E8%A1%A8_1606032043259.png)

`StoreLoad Barriers` 是一个**“全能型”**的屏障，它同时具有其它 3 个屏障的效果。现代的多处理器大多支持该屏障（其它类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（Buffer Fully Flush）。

## 3、volatile 保证可见性的实现原理

- 可能是通过锁总线实现的。
- 也可能是通过 **CPU 缓存一致性协议**（ MESI 协议是一个基于失效的 CPU 缓存一致性协议）实现的。
- 也可能是通过其它方式实现的。

JMM 在不同的系统或 CPU 架构会使用不同的方式，比如在 bsd 里面是直接锁总线。

---

通过上文的内存屏障可知，内存屏障也为 volatile 保证可见性的实现贡献了一分力。

---

- [该回答的评论区 -> “塑料袋”的回答下的 “惊帆”的回复](https://www.zhihu.com/question/296949412/answer/2709967017)
- [如何理解 volatile 、happen-before 、重排序 的关系？ - Java3y 的回答](https://www.zhihu.com/question/499586720/answer/2350034212)

### 缓存一致性协议

在多核处理器系统中每个处理器都有自己的高速缓存，也就有可能（必然）会缓存相同内存区域的数据，此时当多个处理器都要修改相同内存区域的数据时，究竟将哪个修改写入内存呐？这就需要缓存一致性协议了，缓存一致性协议有很多种：

1. 日常接触到的大多数计算机设备使用的都属于“窥探（snooping）”协议
2. MESI 协议

#### 窥探协议

我们都知道所有内存传输都发生在一条共享的总线上，每个 CPU 会窥探总线上发生的数据交换，若发现自己的缓存被别人修改了，就会将自己的缓存过期掉。

##### 窥探协议的缺陷

在直写模式下，没有什么窥探协议没有什么问题，因为写操作一旦发生，它的效果马上会被“公布”出去。但是如果混着回写模式，就有问题了。因为有可能在写指令执行过后很久，数据才会被真正回写到物理内存中——在这段时间内，其它处理器的缓存也可能会傻乎乎地去写同一块内存地址，导致冲突。

在回写模型中，简单把内存写操作的信息广播给其他处理器是不够的，我们需要做的是，在修改本地缓存之前，就要告知其他处理器。

#### MESI 协议

搞懂了细节，就找到了处理回写模式这个问题的最简单方案，我们通常叫做 MESI 协议。

MESI 是 Modified、Exclusive、Shared、Invalid 的首字母缩写，代表四种缓存状态。

[关于 MESI 以及衍生协议](https://www.infoq.cn/article/cache-coherency-primer)

## 4、为何 volatile 不保证原子性

对 volatile 变量的修改在底层是由多个 CPU 指令实现的，当多个线程同时对 volatile 变量修改时，这些指令都混合在了一起因此不能保证原子性。而 Synchronize 关键字不同，关于 Synchronize 原子性的实现原理可以前面提过。

## 5、volatile 的使用优化

### 追加字节优化性能

Doug lea 在 JDK 7 中新增了 LinkedTransferQueue 类，该类使用了 PaddedAtomicReference 类定义头结点和尾结点。PaddedAtomicReference 类相较于父类只做了一件事，就是内部创建了多个无用对象引用，从而使 PaddedAtomicReference 的实例对象大小相较于父类增加到了 64 字节，源码如下：

```java
private transient final PaddedAtomicReference<Node> head;
private transient final PaddedAtomicReference<Node> tail;

static final class PaddedAtomicReference <T> extends AtomicReference <T> {
    // 一个引用 4 字节，这里共 15 个引用 60 字节
    Object p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, pa, pb, pc, pd, pe;
    PaddedAtomicReference(T r) {
        super(r);
    }
}

public class AtomicReference <V> implements Serializable {
    // 这里有 4 字节
    private volatile V value;
}
```

#### 为啥这样可以提高性能

因为英特尔酷睿、Atom 和 NetBurst 等处理器的高速缓冲区的缓存行是 64 字节，且不允许缓存行空填充，这意味着当头尾节点都不足 64 字节时，处理器会将它们读到同一个高速缓存行中，在多处理器下当一个处理器试图修改头结点时，该处理器会独占该缓存行，这会导致其它处理器不能修改自己高速缓存中的尾结点缓存行（为什么不能修改，看前面的 MESI 协议），从而影响了队列的出队入队效率，通过增加字节避免了头尾结点加载到同一个缓存行，使头尾结点在修改时不会因为缓存行独占而阻塞修改。

#### 为何不应该使用 volatile 变量时都增加到 64 字节

1. 对于缓存行非 64 字节宽的处理器不应该增加字节。
2. 对于不会频繁写的共享变量不应该增加字节。

# TODO

[如何理解 volatile 、happen-before 、重排序 的关系？ - Java3y 的回答](https://www.zhihu.com/question/499586720/answer/2350034212)

### happens-before：规定了何时不能重排序

> Java 为重排序添加了一些规则，这些规则就叫：happens-before ，这些规则规定了某些情况下不能进行指令重排序。

#### 与程序员密切相关的 happens-before 规则如下

- 程序顺序规则：

	一个线程内，写在前面的操作先执行发生于写在后面的操作。

- 锁规则：

	对一个锁的 unLock ，先行发生于后面对该锁的 lock 操作。

- volatile 变量规则：

	对一个 volatile 变量的写操作，先行发生于后续对这个 volatile 变量的读操作。

- 传递性：

	如果 A happens-before B，且 B happens-before C，那么 A happens-before C。

#### happens-before 与 重排序 的关系

![happens-before 与 JMM 的关系](https://raw.githubusercontent.com/ZGW-GitHub/NoteImages/main/transfer/blog-img-master/2020/11/happens-before%20%E4%B8%8E%20JMM%20%E7%9A%84%E5%85%B3%E7%B3%BB_1606032050429.png)

如上图所示：一个 happens-before 规则对应于一个或多个编译器和处理器重排序规则。对于 Java 程序员来说，happens-before 规则简单易懂，它避免 Java 程序员为了理解 JMM 提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现方法。

